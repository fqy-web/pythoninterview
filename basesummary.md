## 第一二章基础知识总结

#### 第一章 python技术面试中的一些问题
1.1  面试解题流程总结
> 算法面试中，要在短时间内去分析问题，设计算法，最后编码实现，然后还要测试代码，分析复杂度，因此，在一次成功的算法面试中，需要展现出以下几方面的能力：
 + 将现实世界的实际问题进行抽象归纳 的能力
 + 在短时间、高压力情况下设计有效算法的能力
 + 较强的编码能力，即将算法步骤转换为具体代码的能力
 + 通过算法进行复杂度分析的能力

1.2 面试的流程
   
1.2.1 面试前
+ 仔细评估目标公司
> 全方位、多角度地了解目标公司地文化、制度、产品、薪酬福利等信息。
- 投递简历
- 电话或网络面试
- 现场面试

1.2.2 简历的制作
- 注重强调自身技术能力与目标公司的匹配度
- 将职位最需要的特长放在开头
- 版面整洁，防止出现过多错别字
  
1.2.3 有效的面试策略
- 主动与面试官沟通
> 在算法题中，主动和面试官沟通，确认好需要及其他必要地信息。
- 使用小样本数据作为思考切入口
> 直接抽象地去思考问题比较难入手，可以尝试认为构造一些小样本数据来激活自己地思考能力。
- 先从最笨、最简单的方法入手
> 先从最简单地方法开始，然后逐步优化，引发后续思路，从而找到更好地解题方法。
- 大胆说出想法，有多少说多少
> 有多少想法就说多少出来，可能会比较乱，但是说出来可以让面试官知道你的想法，并且引导到正确的方向上去。
- 采用算法模式套路
> 数据结构方面可优先考虑二叉树、链表、堆栈；算法方面优先考虑排序、二分查找、分而治之鞥。
3. 面试过程中的交流要点
- 看你是否有清晰的表达能力
> 在面对面进行表述时，应放慢语速，注意表达清晰，必要时通过白板或书写来辅助表达，表述时留意面试官的反应，并对他的反应及时做出响应。
- 考察你是否有工作激情
>   团队都希望找到有激情和主动性的员工，这样有利于提振团队士气。谈自己的项目时，挑一个最有成就 感的，这样在说的时候有利于激发内心的正能量。
- 一定要诚恳、诚实
> 不要超出自己得能力范围内。
- 不要随意道歉
> 技术上的弱点，做得不好的地方或者之前的成绩不太好，不要随意道歉。比如“不好意思，我大学成绩不是很好”，“对不起，我代码写得不够严谨”，这类道歉企图想通过示弱的方式讨好面试官，期望减少刁难或降低面试难度。要自信，过去或者现在做得不好得地方，发现了不足，下来了或以后要好好改进。
- 注意肢体语言
> 注重眼神交流，不要弯腰驼背，握手时注意力道，脸上时刻保持微笑，给人留下一个好的印象。
- 不要在技术面中谈钱
> 工资福利是重要议题，但要留着跟HR谈。
- 保持镇定
> 不卑不亢，相信自己，从容面对。

#### 第二章 算法面试中的数据基础知识

2.1 算法面试中常用的数据结构
+ 基础数据类型, int , bool, float等

```
例子：给定一个整数x，计算它的二进制形式中包含多少个1

# 暴力枚举法

import time
x = bin(int(input('>>')))
a = time.time()

count = 0   # 保存1的个数
print(x)
for i in x: 
    # 遍历有多少个1
    if i == '1':
        count += 1

print('count:', count)
a = time.time() - a
print(a,'s')


# 更优解

# 实现思路为二进制形式中有几个1就执行几次循环，复杂度为1的个数，而不用遍历每个数
# x&=(x-1)的作用是将x二进制形式中最右边的1抹除掉，即转换为0

def countOnes(x):
    count = 0
    while x > 0:
        count += 1
        x&= (x-1)
    return count

import time
a = time.time()
c = countOnes(1234)
print('binary form of 1234 is {}'.format(bin(1234)))
print('binary form of 1234 contains {} ls'.format(c))
a = time.time() - a    # 计算函数执行所需的时间
print(a, 's')
```

- 数组与字符串
> 数组算法题大多涉及排序
- 链表
> 链表是算法面试题中的常客,和数组比各有优势,有关链表的算法题大多涉及链表的操作和结构判断.
- 堆栈
> 堆栈是一种后进先出的数据结构.
- 二叉树
> 二叉树在面试题目中最常用于查找和遍历,需要掌握二叉树的前序,中序,后序这三种遍历方式.
- 堆
> 堆是一种特殊的二叉树,也被称为优先级队列.其显著特点是,它的根节点是所有节点中的最大或最小值.
- 哈希表
> 哈希表最广泛的用处在于查询数据,其插入,删除,查找的复杂度都是O(1),哈希表设计的关键在于哈希函数, 其计算值要尽量接近独立统一分布.

2.2 算法的常用设计模式
- 排序
```
> 问题描述： 给定一个整型数组A， 以及整数M，判断A中是否包含这样的i，j
# ，使得M = A[i] + A[j]

# 1 暴力枚举法
# 不用考虑先排序
# 算法升级： 如果存在则返回两个数的下标
A = [1,2,3,4,5,6]
#A =[1,2]
M = 10
success = False
a = 0
b = 0
for i in A:
   # print("i:",i)
    for j in A:
        if i != j:
           # print('j:',j)
            if (i + j) == M:
                success = True
                a = i
                b = j
                    
print(a, b, success)


# 折中查找，也叫二分查找
# 根据实际测试，只能看能否找到这个数，不能返回正确的下标，需要重新设计
def binaryFind(A, m):
    if len(A) == 0:
        return -1
    
    i = len(A)//2
   # print(i)

    if A[i] == m:
        return A[i]
    if A[i] > m and i - 1 >= 0:
        return binaryFind(A[0:i], m)
    if A[i] < m and i + 1 < len(A):
        return binaryFind(A[i: len(A)], m)

    return -1
A = [3, 1, 5, 6, 7, 4, 2, 8]
m = 1
# 把A按升序排列
A.sort()
#print(binaryFind(A,m))

# print(A)
success  = False
#A =[2,6]
M = 11
for i in A:
    m = M - i
    j = binaryFind(A, m)
    if j != -1 and j != i:
        print('存在i和j使得A[i] + A[j] = {}'.format(M))
        success = True
        break
if not success:
    print('不存在i和j使得A[i] + A[j] = {}'.format(M))
    
```

+ 递归
> 递归是指一个函数在执行过程中再度调用它自己.当一个大问题能够分解成多个结构相同的子问题时,使用递归处理就很合适.前面的binaryFind()就使用了这样的思想.
+ 分而治之
> 分而治之就是把问题分解成若干个规模更小的子问题.如果子问题容易解决,那么解决子问题后,把所有结果整合起来便形成原有问题的解


                


